import { readdirSync, readFileSync, statSync, writeFileSync } from "fs";
import { join, relative } from "path";
import imageSize from "image-size";

const PUBLIC_DIR = join(process.cwd(), "public");
const PORTFOLIO_DIR = join(PUBLIC_DIR, "images/portfolio");
const OUTPUT_FILE = join(process.cwd(), "src/lib/image-dimensions.ts");

type Dimensions = { width: number; height: number };
const dimensionsMap: Record<string, Dimensions> = {};

function scanDirectory(dir: string) {
  const entries = readdirSync(dir);

  for (const entry of entries) {
    const fullPath = join(dir, entry);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      scanDirectory(fullPath);
    } else if (/\.(avif|webp|png|jpg|jpeg)$/i.test(entry)) {
      try {
        const buffer = readFileSync(fullPath);
        const result = imageSize(buffer);
        if (result.width && result.height) {
          // Convert to path relative to /public (e.g., "/images/portfolio/...")
          const relativePath = "/" + relative(PUBLIC_DIR, fullPath);
          dimensionsMap[relativePath] = {
            width: result.width,
            height: result.height,
          };
        }
      } catch (err) {
        console.error(`Failed to read dimensions for ${fullPath}:`, err);
      }
    }
  }
}

console.log("Scanning portfolio images...");
scanDirectory(PORTFOLIO_DIR);

const output = `// Auto-generated by scripts/generate-image-dimensions.ts
// Run: pnpm tsx scripts/generate-image-dimensions.ts

export const imageDimensions: Record<string, { width: number; height: number }> = ${JSON.stringify(dimensionsMap, null, 2)};

export function getImageDimensions(src: string): { width: number; height: number } | undefined {
  return imageDimensions[src];
}
`;

writeFileSync(OUTPUT_FILE, output);
console.log(`Generated ${OUTPUT_FILE} with ${Object.keys(dimensionsMap).length} images.`);
